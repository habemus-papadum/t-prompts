import esbuild from 'esbuild';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function filterSourceMap(sourceMapPath) {
  // Read the source map
  const sourceMap = JSON.parse(fs.readFileSync(sourceMapPath, 'utf8'));

  // Filter out node_modules from sources and sourcesContent
  const filteredIndices = [];
  const filteredSources = [];
  const filteredSourcesContent = [];

  sourceMap.sources.forEach((source, index) => {
    if (!source.includes('node_modules')) {
      filteredIndices.push(index);
      filteredSources.push(source);
      if (sourceMap.sourcesContent && sourceMap.sourcesContent[index]) {
        filteredSourcesContent.push(sourceMap.sourcesContent[index]);
      }
    }
  });

  // Update the source map
  sourceMap.sources = filteredSources;
  if (sourceMap.sourcesContent && sourceMap.sourcesContent.length > 0) {
    sourceMap.sourcesContent = filteredSourcesContent;
  }

  // Write the filtered source map back
  fs.writeFileSync(sourceMapPath, JSON.stringify(sourceMap));
  console.log(`  Filtered source map: removed ${sourceMap.sources.length - filteredSources.length} node_modules entries`);
}

function copyDistToPython() {
  const distDir = path.join(__dirname, 'dist');
  const pythonWidgetsDir = path.join(__dirname, '..', 'src', 't_prompts', 'widgets');

  // Ensure Python widgets directory exists
  if (!fs.existsSync(pythonWidgetsDir)) {
    fs.mkdirSync(pythonWidgetsDir, { recursive: true });
  }

  // Copy .js and .map files from dist/ to Python package
  const files = fs.readdirSync(distDir);
  for (const file of files) {
    const ext = path.extname(file);
    if (ext === '.js' || ext === '.map') {
      const srcPath = path.join(distDir, file);
      const destPath = path.join(pythonWidgetsDir, file);
      fs.copyFileSync(srcPath, destPath);
      console.log(`  Copied ${file} to Python package`);
    }
  }
}

function generateStylesHash() {
  // Read styles.css and generate a hash
  const stylesPath = path.join(__dirname, 'src', 'styles.css');
  const stylesContent = fs.readFileSync(stylesPath, 'utf8');
  const hash = crypto.createHash('sha256').update(stylesContent).digest('hex').substring(0, 8);

  // Write the hash to a generated TypeScript file
  const generatedPath = path.join(__dirname, 'src', 'generated.ts');
  const content = `// Auto-generated by build.js - do not edit manually
export const STYLES_HASH = '${hash}';
`;
  fs.writeFileSync(generatedPath, content);
  console.log(`  Generated styles hash: ${hash}`);

  return hash;
}

async function build() {
  const outdir = path.join(__dirname, 'dist');

  // Ensure output directory exists
  if (!fs.existsSync(outdir)) {
    fs.mkdirSync(outdir, { recursive: true });
  }

  // Generate styles hash before building
  generateStylesHash();

  try {
    // Build JavaScript
    await esbuild.build({
      entryPoints: ['src/index.ts'],
      bundle: true,
      minify: true,
      sourcemap: true,
      target: ['es2020'],
      format: 'iife',
      globalName: 'TPromptsWidgets',
      outfile: path.join(outdir, 'index.js'),
      platform: 'browser',
      metafile: true,
      logLevel: 'info',
      loader: {
        '.css': 'text',  // Import CSS as text string in JS
      },
    });

    console.log('✓ Build completed successfully');

    // Filter source map to exclude node_modules
    const sourceMapPath = path.join(outdir, 'index.js.map');
    if (fs.existsSync(sourceMapPath)) {
      filterSourceMap(sourceMapPath);
      console.log('✓ Source map filtered');
    }

    // Copy dist to Python package
    copyDistToPython();
    console.log('✓ Copied to Python package');
  } catch (error) {
    console.error('✗ Build failed:', error);
    process.exit(1);
  }
}

build();
