{
  "version": 3,
  "sources": ["../src/index.ts", "../src/metadata.ts", "../src/transforms/base.ts", "../src/transforms/createChunks.ts", "../src/transforms/typing.ts", "../src/transforms/imageTruncate.ts", "../src/transforms/imageHoverPreview.ts", "../src/transforms/boundaries.ts", "../src/components/CodeView.ts", "../src/components/WidgetContainer.ts", "../src/renderer.ts", "../src/styles.css", "../src/generated.ts"],
  "sourcesContent": ["/**\n * Jupyter notebook widgets for visualizing t-prompts structures.\n * Phase 0 & 1: Asset de-duplication and minimal static renderer\n */\n\nimport { initWidget } from './renderer';\nimport widgetStyles from './styles.css';\nimport { STYLES_HASH } from './generated';\n\n// Export version matching Python package\nexport const VERSION = '0.9.0-alpha';\n\n// Store widget runtime on window for singleton pattern (Phase 0)\ndeclare global {\n  interface Window {\n    __TPWidget?: {\n      version: string;\n      initWidget: typeof initWidget;\n      stylesInjected: boolean;\n    };\n  }\n}\n\n/**\n * Inject widget styles into the document (once per page)\n */\nfunction injectStyles(): void {\n  // Use hash-based style ID for cache busting\n  const styleId = `tp-widget-styles-${STYLES_HASH}`;\n\n  // Check if this version is already injected\n  // Use querySelector instead of getElementById for reliability across environments\n  if (document.querySelector(`#${styleId}`)) {\n    return;\n  }\n\n  // Remove any old versions of the styles\n  const oldStyles = document.querySelectorAll('[id^=\"tp-widget-styles\"]');\n  oldStyles.forEach(el => el.remove());\n\n  // Inject new styles\n  const styleElement = document.createElement('style');\n  styleElement.id = styleId;\n  styleElement.textContent = widgetStyles;\n  document.head.appendChild(styleElement);\n\n  if (window.__TPWidget) {\n    window.__TPWidget.stylesInjected = true;\n  }\n}\n\n/**\n * Initialize the widget runtime on window (Phase 0 singleton)\n */\nfunction initRuntime(): void {\n  if (!window.__TPWidget) {\n    window.__TPWidget = {\n      version: VERSION,\n      initWidget,\n      stylesInjected: false,\n    };\n  }\n}\n\n/**\n * Auto-initialize all widgets on the page\n */\nfunction autoInit(): void {\n  initRuntime();\n  injectStyles();\n\n  // Find all widget containers and initialize them\n  const containers = document.querySelectorAll('[data-tp-widget]');\n  containers.forEach((container) => {\n    if (container instanceof HTMLElement && !container.dataset.tpInitialized) {\n      initWidget(container);\n      container.dataset.tpInitialized = 'true';\n    }\n  });\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Watch for new widgets being added to the page (for Jupyter dynamic cell rendering)\nif (typeof MutationObserver !== 'undefined') {\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node instanceof HTMLElement) {\n          // Check if this node is a widget container\n          if (node.matches('[data-tp-widget]') && !node.dataset.tpInitialized) {\n            initRuntime();\n            injectStyles();\n            initWidget(node);\n            node.dataset.tpInitialized = 'true';\n          }\n          // Check if this node contains widget containers\n          const widgets = node.querySelectorAll('[data-tp-widget]');\n          widgets.forEach((widget) => {\n            if (widget instanceof HTMLElement && !widget.dataset.tpInitialized) {\n              initRuntime();\n              injectStyles();\n              initWidget(widget);\n              widget.dataset.tpInitialized = 'true';\n            }\n          });\n        }\n      });\n    });\n  });\n\n  // Observe the entire document body for new widgets\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true,\n  });\n}\n\n// Export for manual initialization\nexport { initWidget, injectStyles, initRuntime };\n", "/**\n * Metadata computation and analysis (Phase 1 & 2)\n *\n * These functions analyze widget data and build lookup maps\n * that are view-agnostic and reusable across visualizations.\n */\n\nimport type {\n  WidgetData,\n  WidgetMetadata,\n  PromptData,\n  ElementData,\n  SourceLocationData,\n} from './types';\n\n/**\n * Trim the source prefix from a file path to make it relative\n *\n * @param filepath - The absolute file path\n * @param prefix - The prefix to remove (e.g., project root directory)\n * @returns The relative path, or original path if prefix doesn't match\n *\n * @example\n * trimSourcePrefix('/Users/dev/project/src/main.py', '/Users/dev/project')\n * // Returns: 'src/main.py'\n */\nexport function trimSourcePrefix(filepath: string | null, prefix: string): string | null {\n  if (!filepath) {\n    return null;\n  }\n\n  // Normalize prefix to ensure it ends with a separator\n  const normalizedPrefix = prefix.endsWith('/') ? prefix : prefix + '/';\n\n  // Check if filepath starts with the prefix\n  if (filepath.startsWith(normalizedPrefix)) {\n    return filepath.substring(normalizedPrefix.length);\n  }\n\n  // Also check without trailing slash in case filepath === prefix\n  if (filepath === prefix) {\n    return '.';\n  }\n\n  // Prefix doesn't match - return original path\n  return filepath;\n}\n\n/**\n * Format a source location as a compact string\n *\n * @param location - The source location data\n * @param sourcePrefix - The prefix to trim from filepaths\n * @returns Formatted location string (e.g., \"src/main.py:42\") or null if location not available\n */\nfunction formatSourceLocation(\n  location: SourceLocationData | null | undefined,\n  sourcePrefix: string\n): string | null {\n  if (!location || !location.filename) {\n    return null;\n  }\n\n  // Use filepath if available, otherwise use filename\n  const path = location.filepath || location.filename;\n  const relativePath = trimSourcePrefix(path, sourcePrefix) || path;\n\n  // Add line number if available\n  if (location.line !== null && location.line !== undefined) {\n    return `${relativePath}:${location.line}`;\n  }\n\n  return relativePath;\n}\n\n/**\n * Build a map from element_id to formatted location string by walking the source prompt tree\n *\n * For elements with both source_location and creation_location (nested prompts),\n * the format is: \"source.py:84 (created: other.py:42)\"\n */\nfunction buildElementLocationMap(\n  promptData: PromptData | null,\n  sourcePrefix: string\n): Record<string, string> {\n  const map: Record<string, string> = {};\n\n  if (!promptData) {\n    return map;\n  }\n\n  function walkElements(elements: ElementData[]): void {\n    for (const element of elements) {\n      // Format source_location (where interpolated/used)\n      const sourceLoc = formatSourceLocation(element.source_location, sourcePrefix);\n\n      // Format creation_location (where originally created)\n      const creationLoc = formatSourceLocation(element.creation_location, sourcePrefix);\n\n      // Build location string\n      if (sourceLoc && creationLoc && sourceLoc !== creationLoc) {\n        // Both locations exist and differ (nested prompt case)\n        map[element.id] = `${sourceLoc} (created: ${creationLoc})`;\n      } else if (sourceLoc) {\n        // Just source location\n        map[element.id] = sourceLoc;\n      } else if (creationLoc) {\n        // Just creation location (shouldn't happen normally)\n        map[element.id] = creationLoc;\n      }\n      // If neither exists, no entry in map\n\n      // Recursively process nested elements\n      if (element.children) {\n        walkElements(element.children);\n      }\n    }\n  }\n\n  // Start walking from the root prompt's children\n  walkElements(promptData.children);\n  return map;\n}\n\n/**\n * Build a map from element_id to element_type by walking the source prompt tree\n */\nfunction buildElementTypeMap(promptData: PromptData | null): Record<string, string> {\n  const map: Record<string, string> = {};\n\n  if (!promptData) {\n    return map;\n  }\n\n  function walkElements(elements: ElementData[]): void {\n    for (const element of elements) {\n      map[element.id] = element.type;\n\n      // Recursively process nested elements\n      if (element.children) {\n        walkElements(element.children);\n      }\n    }\n  }\n\n  // Start walking from the root prompt's children\n  walkElements(promptData.children);\n  return map;\n}\n\n/**\n * Compute all widget metadata from widget data.\n * This centralizes all map-building logic and creates view-agnostic metadata\n * that can be reused across different visualizations.\n *\n * @param data - The widget data\n * @returns Metadata containing all computed maps\n */\nexport function computeWidgetMetadata(data: WidgetData): WidgetMetadata {\n  const sourcePrefix = data.config?.sourcePrefix || '';\n\n  return {\n    elementTypeMap: buildElementTypeMap(data.source_prompt || null),\n    elementLocationMap: buildElementLocationMap(data.source_prompt || null, sourcePrefix),\n  };\n}\n", "/**\n * Transform pipeline infrastructure\n *\n * Transforms are pure functions that take state and return modified state.\n * They allow incremental modification of DOM structure and data.\n */\n\nimport type { WidgetData, WidgetMetadata } from '../types';\n\n/**\n * State that flows through the transform pipeline\n */\nexport interface TransformState {\n  // DOM\n  element: HTMLElement;\n  chunks: Map<string, HTMLElement[]>; // chunkId \u2192 array of top-level DOM elements\n\n  // Data\n  data: WidgetData;\n  metadata: WidgetMetadata;\n\n  // Analysis results (built incrementally)\n  // Future: textMapping, lineBreaks, syntaxTree, etc.\n}\n\n/**\n * Transform function signature\n * Takes state, returns modified state\n */\nexport type Transform = (state: TransformState) => TransformState;\n\n/**\n * Chunk ID Utilities\n *\n * Chunks are identified using data-chunk-id attributes rather than HTML IDs.\n * This allows multiple DOM elements to be associated with the same chunk.\n */\n\n/**\n * Get the chunk ID from an element's data-chunk-id attribute\n */\nexport function getChunkId(element: HTMLElement): string | null {\n  return element.getAttribute('data-chunk-id');\n}\n\n/**\n * Copy chunk ID from one element to another\n */\nexport function copyChunkId(fromElement: HTMLElement, toElement: HTMLElement): void {\n  const chunkId = getChunkId(fromElement);\n  if (chunkId) {\n    toElement.setAttribute('data-chunk-id', chunkId);\n  }\n}\n\n/**\n * Add an element to the chunks map for a given chunk ID\n */\nexport function addToChunksMap(\n  chunkId: string,\n  element: HTMLElement,\n  map: Map<string, HTMLElement[]>\n): void {\n  const existing = map.get(chunkId);\n  if (existing) {\n    existing.push(element);\n  } else {\n    map.set(chunkId, [element]);\n  }\n}\n\n/**\n * Remove a specific element from the chunks map for a given chunk ID\n */\nexport function removeFromChunksMap(\n  chunkId: string,\n  element: HTMLElement,\n  map: Map<string, HTMLElement[]>\n): void {\n  const existing = map.get(chunkId);\n  if (existing) {\n    const index = existing.indexOf(element);\n    if (index !== -1) {\n      existing.splice(index, 1);\n    }\n    // Remove the key entirely if array is now empty\n    if (existing.length === 0) {\n      map.delete(chunkId);\n    }\n  }\n}\n", "/**\n * Create Chunks Transform\n *\n * Creates initial <span> elements for each chunk and adds them to the DOM.\n * This is the first transform in the pipeline - it builds the raw structure.\n */\n\nimport type { TransformState } from './base';\nimport { addToChunksMap } from './base';\n\n/**\n * Create initial DOM elements for all chunks\n */\nexport function applyTransform_CreateChunks(state: TransformState): TransformState {\n  const { element, chunks, data } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  // Process each chunk\n  for (const chunk of data.ir.chunks) {\n    let chunkElement: HTMLElement;\n\n    if (chunk.type === 'TextChunk' && chunk.text !== undefined) {\n      // Text chunk - simple span with text content\n      const span = document.createElement('span');\n      span.setAttribute('data-chunk-id', chunk.id);\n      span.textContent = chunk.text;\n      chunkElement = span;\n    } else if (chunk.type === 'ImageChunk' && chunk.image) {\n      // Image chunk - simple span with text placeholder\n      // (Hover preview can be added via future transform)\n      const imgData = chunk.image;\n      const format = imgData.format || 'PNG';\n      const dataUrl = `data:image/${format.toLowerCase()};base64,${imgData.base64_data}`;\n      const chunkText = `![${format} ${imgData.width}x${imgData.height}](${dataUrl})`;\n\n      const span = document.createElement('span');\n      span.setAttribute('data-chunk-id', chunk.id);\n      span.textContent = chunkText;\n      // Store image data on element for future transforms\n      (span as HTMLElement & { _imageData?: typeof imgData })._imageData = imgData;\n      chunkElement = span;\n    } else {\n      // Unknown chunk type - empty span\n      const span = document.createElement('span');\n      span.setAttribute('data-chunk-id', chunk.id);\n      chunkElement = span;\n    }\n\n    // Add to chunks map\n    addToChunksMap(chunk.id, chunkElement, chunks);\n\n    // Append to DOM\n    element.appendChild(chunkElement);\n  }\n\n  return state;\n}\n", "/**\n * Typing Transform\n *\n * Adds type-based CSS classes to chunks and source location tooltips.\n * This enables semantic coloring and provides developer metadata on hover.\n */\n\nimport type { TransformState } from './base';\n\n/**\n * Add type classes and location tooltips to all chunks\n */\nexport function applyTransform_AddTyping(state: TransformState): TransformState {\n  const { chunks, data, metadata } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  for (const chunk of data.ir.chunks) {\n    const elements = chunks.get(chunk.id);\n    if (!elements) continue;\n\n    // Apply typing to all elements for this chunk\n    for (const chunkElement of elements) {\n      // Determine element type and apply CSS class\n      const elementType = metadata.elementTypeMap[chunk.element_id] || 'unknown';\n      chunkElement.className = `tp-chunk-${elementType}`;\n\n      // Add source location as title (hover tooltip) if available\n      const location = metadata.elementLocationMap[chunk.element_id];\n      if (location) {\n        chunkElement.title = location;\n      }\n    }\n  }\n\n  return state;\n}\n", "/**\n * Image Truncate Transform\n *\n * Truncates the base64 data URL in image chunks to a simple \"(...)\".\n * This keeps the text short for better line wrapping and readability,\n * while maintaining the image format and dimensions in the placeholder.\n */\n\nimport type { TransformState } from './base';\nimport type { ImageData } from '../types';\n\n/**\n * Truncate image data URLs in text content\n */\nexport function applyTransform_ImageTruncate(state: TransformState): TransformState {\n  const { chunks } = state;\n\n  // Process all chunks\n  for (const [, chunkElement] of chunks) {\n    // Check if this chunk has image data stored\n    const imageData = (chunkElement as HTMLElement & { _imageData?: ImageData })._imageData;\n    if (!imageData) continue;\n\n    // Truncate the text to remove the long base64 data URL\n    const format = imageData.format || 'PNG';\n    const truncatedText = `![${format} ${imageData.width}x${imageData.height}](...)`;\n    chunkElement.textContent = truncatedText;\n\n    // Remove title attribute - we don't want source location tooltip on images\n    // since they'll have hover preview instead\n    chunkElement.removeAttribute('title');\n  }\n\n  return state;\n}\n", "/**\n * Image Hover Preview Transform\n *\n * Adds hover preview functionality for image chunks.\n * Wraps image placeholder text in a container and adds a hidden preview image\n * that appears on hover (via CSS).\n */\n\nimport type { TransformState } from './base';\nimport { copyChunkId, addToChunksMap, removeFromChunksMap } from './base';\nimport type { ImageData } from '../types';\n\n/**\n * Add hover preview support for images\n */\nexport function applyTransform_ImageHoverPreview(state: TransformState): TransformState {\n  const { chunks } = state;\n\n  // Process all chunks - iterate over a copy since we'll be modifying the map\n  for (const [chunkId, elements] of Array.from(chunks.entries())) {\n    // Process each element for this chunk\n    for (const chunkElement of elements) {\n      // Check if this chunk has image data stored\n      const imageData = (chunkElement as HTMLElement & { _imageData?: ImageData })._imageData;\n      if (!imageData) continue;\n\n      // Build data URL for the preview\n      const format = imageData.format || 'PNG';\n      const dataUrl = `data:image/${format.toLowerCase()};base64,${imageData.base64_data}`;\n\n      // Create container span\n      const container = document.createElement('span');\n      container.className = 'tp-chunk-image-container';\n\n      // Copy chunk ID to the new container\n      copyChunkId(chunkElement, container);\n\n      // Copy any existing classes from the chunk element (e.g., tp-chunk-image, type classes)\n      if (chunkElement.className) {\n        container.className += ` ${chunkElement.className}`;\n      }\n\n      // Create text span (no data-chunk-id needed, just for display)\n      const textSpan = document.createElement('span');\n      textSpan.className = 'tp-chunk-image';\n      textSpan.textContent = chunkElement.textContent;\n\n      // Create preview image (hidden by default, shown on hover via CSS)\n      const previewImg = document.createElement('img');\n      previewImg.className = 'tp-chunk-image-preview';\n      previewImg.src = dataUrl;\n      previewImg.alt = `${format} ${imageData.width}x${imageData.height}`;\n\n      // Assemble container\n      container.appendChild(textSpan);\n      container.appendChild(previewImg);\n\n      // Replace original element in DOM\n      if (chunkElement.parentNode) {\n        chunkElement.parentNode.replaceChild(container, chunkElement);\n      }\n\n      // Update chunks map: remove old element, add new container\n      removeFromChunksMap(chunkId, chunkElement, chunks);\n      addToChunksMap(chunkId, container, chunks);\n    }\n  }\n\n  return state;\n}\n", "/**\n * Boundaries Transform\n *\n * Marks first and last chunks of each element with boundary classes.\n * This enables visual boundary indicators (colored bars) in the CSS.\n */\n\nimport type { TransformState } from './base';\n\n/**\n * Mark first and last chunks for each element\n */\nexport function applyTransform_MarkBoundaries(state: TransformState): TransformState {\n  const { chunks, data, metadata } = state;\n\n  if (!data.compiled_ir?.subtree_map) {\n    return state;\n  }\n\n  // Iterate through each element and its chunks\n  for (const [elementId, chunkIds] of Object.entries(data.compiled_ir.subtree_map)) {\n    if (chunkIds.length === 0) {\n      continue;\n    }\n\n    // Get element type for this element\n    const elementType = metadata.elementTypeMap[elementId] || 'unknown';\n\n    // Mark first chunk - get all elements for this chunk\n    const firstChunkId = chunkIds[0];\n    const firstElements = chunks.get(firstChunkId);\n    if (firstElements) {\n      for (const el of firstElements) {\n        el.classList.add(`tp-first-${elementType}`);\n      }\n    }\n\n    // Mark last chunk\n    const lastChunkId = chunkIds[chunkIds.length - 1];\n    const lastElements = chunks.get(lastChunkId);\n    if (lastElements) {\n      for (const el of lastElements) {\n        el.classList.add(`tp-last-${elementType}`);\n      }\n    }\n  }\n\n  return state;\n}\n", "/**\n * Code View Component\n *\n * Renders text output with semantic coloring and element boundaries.\n * Uses a transform pipeline to incrementally build and annotate the DOM.\n */\n\nimport type { Component } from './base';\nimport type { WidgetData, WidgetMetadata } from '../types';\nimport type { TransformState } from '../transforms/base';\nimport { applyTransform_CreateChunks } from '../transforms/createChunks';\nimport { applyTransform_AddTyping } from '../transforms/typing';\nimport { applyTransform_ImageTruncate } from '../transforms/imageTruncate';\nimport { applyTransform_ImageHoverPreview } from '../transforms/imageHoverPreview';\nimport { applyTransform_MarkBoundaries } from '../transforms/boundaries';\n\n/**\n * Code view component interface\n */\nexport interface CodeView extends Component {\n  // Text-specific data\n  chunks: Map<string, HTMLElement[]>; // chunkId \u2192 array of top-level DOM elements\n}\n\n/**\n * Build a CodeView component from widget data and metadata\n */\nexport function buildCodeView(data: WidgetData, metadata: WidgetMetadata): CodeView {\n  // 1. Create initial DOM structure\n  const element = document.createElement('div');\n  element.className = 'tp-output-container wrap';\n\n  // 2. Build chunks map\n  const chunks = new Map<string, HTMLElement[]>();\n\n  // 3. Apply transformation pipeline\n  let state: TransformState = { element, chunks, data, metadata };\n\n  // Transform pipeline - each function modifies state\n  state = applyTransform_CreateChunks(state);\n  state = applyTransform_AddTyping(state);\n  state = applyTransform_ImageTruncate(state);\n  state = applyTransform_ImageHoverPreview(state);\n  state = applyTransform_MarkBoundaries(state);\n\n  // Future transforms can be added here:\n  // state = applyTransform_LineWrapping(state);\n  // state = applyTransform_SyntaxHighlighting(state);\n\n  // 4. Return component with operations\n  return {\n    element: state.element,\n    chunks: state.chunks,\n\n    hide(ids: string[]): void {\n      ids.forEach((id) => {\n        const elements = chunks.get(id);\n        if (elements) {\n          elements.forEach((el) => (el.style.display = 'none'));\n        }\n      });\n    },\n\n    show(ids: string[]): void {\n      ids.forEach((id) => {\n        const elements = chunks.get(id);\n        if (elements) {\n          elements.forEach((el) => (el.style.display = ''));\n        }\n      });\n    },\n\n    destroy(): void {\n      element.remove();\n      chunks.clear();\n    },\n  };\n}\n", "/**\n * Widget Container Component\n *\n * Top-level container that orchestrates multiple views and toolbars.\n * Currently contains just CodeView, but designed to support:\n * - Toolbar for view switching and controls\n * - Multiple visualization views (tree, table, etc.)\n */\n\nimport type { Component } from './base';\nimport type { WidgetData, WidgetMetadata } from '../types';\nimport { buildCodeView } from './CodeView';\n\n/**\n * Widget container component interface\n */\nexport interface WidgetContainer extends Component {\n  // Container-specific\n  views: Component[]; // Child components\n  toolbar?: HTMLElement; // Future: toolbar\n\n  // Operations\n  addView(view: Component): void;\n  removeView(view: Component): void;\n}\n\n/**\n * Build a WidgetContainer component from widget data and metadata\n */\nexport function buildWidgetContainer(data: WidgetData, metadata: WidgetMetadata): WidgetContainer {\n  // 1. Create root element\n  const element = document.createElement('div');\n  element.className = 'tp-widget-output';\n\n  // 2. Build code view\n  const codeView = buildCodeView(data, metadata);\n\n  // 3. Assemble\n  // Future: Add toolbar here\n  // const toolbar = createToolbar();\n  // element.appendChild(toolbar);\n\n  element.appendChild(codeView.element);\n\n  // 4. Track views\n  const views: Component[] = [codeView];\n\n  // 5. Return component\n  return {\n    element,\n    views,\n    toolbar: undefined, // Future\n\n    hide(ids: string[]): void {\n      // Delegate to all views\n      views.forEach((view) => view.hide(ids));\n    },\n\n    show(ids: string[]): void {\n      // Delegate to all views\n      views.forEach((view) => view.show(ids));\n    },\n\n    destroy(): void {\n      // Cleanup all views\n      views.forEach((view) => view.destroy());\n      element.remove();\n    },\n\n    addView(view: Component): void {\n      views.push(view);\n      element.appendChild(view.element);\n    },\n\n    removeView(view: Component): void {\n      const index = views.indexOf(view);\n      if (index !== -1) {\n        views.splice(index, 1);\n        view.element.remove();\n      }\n    },\n  };\n}\n", "/**\n * Widget renderer - main orchestrator\n *\n * Simplified to just:\n * 1. Parse JSON data\n * 2. Compute metadata\n * 3. Build widget component\n * 4. Mount to DOM\n */\n\nimport type { WidgetData } from './types';\nimport { computeWidgetMetadata } from './metadata';\nimport { buildWidgetContainer } from './components/WidgetContainer';\n\n/**\n * Initialize a widget in the given container\n *\n * This is the main entry point called by index.ts\n */\nexport function initWidget(container: HTMLElement): void {\n  try {\n    // 1. Parse embedded JSON data\n    const scriptTag = container.querySelector('script[data-role=\"tp-widget-data\"]');\n    if (!scriptTag || !scriptTag.textContent) {\n      container.innerHTML = '<div class=\"tp-error\">No widget data found</div>';\n      return;\n    }\n\n    const data: WidgetData = JSON.parse(scriptTag.textContent);\n\n    // 2. Validate data\n    if (!data.ir || !data.ir.chunks) {\n      container.innerHTML = '<div class=\"tp-error\">No chunks found in widget data</div>';\n      return;\n    }\n\n    // 3. Compute metadata (Phase 1 & 2)\n    const metadata = computeWidgetMetadata(data);\n\n    // 4. Build widget component (Phase 3)\n    const widget = buildWidgetContainer(data, metadata);\n\n    // 5. Mount to DOM\n    const mountPoint = container.querySelector('.tp-widget-mount');\n    if (mountPoint) {\n      mountPoint.innerHTML = '';\n      mountPoint.appendChild(widget.element);\n    } else {\n      container.innerHTML = '';\n      container.appendChild(widget.element);\n    }\n\n    // 6. Store component reference for future access\n    (container as HTMLElement & { _widgetComponent?: typeof widget })._widgetComponent = widget;\n  } catch (error) {\n    console.error('Widget initialization error:', error);\n    container.innerHTML = `<div class=\"tp-error\">Failed to initialize widget: ${\n      error instanceof Error ? error.message : String(error)\n    }</div>`;\n  }\n}\n", "/* T-Prompts Widget Styles */\n\n/* =============================================================================\n   CSS VARIABLES FOR THEMING\n   ============================================================================= */\n\n/* Base UI Variables */\n:root {\n  --tp-color-bg: #ffffff;\n  --tp-color-fg: #24292e;\n  --tp-color-border: #e1e4e8;\n  --tp-color-accent: #0366d6;\n  --tp-color-muted: #6a737d;\n  --tp-color-error: #d73a49;\n  --tp-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;\n  --tp-font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;\n  --tp-spacing: 8px;\n\n  /* ==========================================================================\n     TIER 1: PALETTE PRIMITIVES - Hue values for each element type\n     ========================================================================== */\n  --tp-hue-static: 220;         /* Neutral blue-gray */\n  --tp-hue-interpolation: 212;  /* Blue - dynamic data */\n  --tp-hue-nested: 270;         /* Purple - compositional structure */\n  --tp-hue-list: 160;           /* Teal - collections */\n  --tp-hue-image: 30;           /* Orange - media */\n  --tp-hue-unknown: 0;          /* Red - warning/edge case */\n\n  /* ==========================================================================\n     TIER 2: SEMANTIC TOKENS - Light Mode\n     Saturation, lightness, and alpha values for foregrounds and backgrounds\n     ========================================================================== */\n\n  /* Static text - minimal styling (baseline) */\n  --tp-static-fg-s: 15%;\n  --tp-static-fg-l: 30%;\n  --tp-static-bg-alpha: 0.04;\n\n  /* Interpolations - blue, medium visibility */\n  --tp-interp-fg-s: 80%;\n  --tp-interp-fg-l: 35%;\n  --tp-interp-bg-alpha: 0.10;\n\n  /* Nested prompts - purple, slightly stronger */\n  --tp-nested-fg-s: 75%;\n  --tp-nested-fg-l: 38%;\n  --tp-nested-bg-alpha: 0.12;\n\n  /* Lists - teal, medium tint (increased visibility) */\n  --tp-list-fg-s: 80%;\n  --tp-list-fg-l: 32%;\n  --tp-list-bg-alpha: 0.14;\n\n  /* Images - orange, distinct */\n  --tp-image-fg-s: 85%;\n  --tp-image-fg-l: 40%;\n  --tp-image-bg-alpha: 0.10;\n\n  /* Unknown - red, warning signal */\n  --tp-unknown-fg-s: 80%;\n  --tp-unknown-fg-l: 45%;\n  --tp-unknown-bg-alpha: 0.12;\n}\n\n/* Dark Mode Overrides */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --tp-color-bg: #0d1117;\n    --tp-color-fg: #c9d1d9;\n    --tp-color-border: #30363d;\n    --tp-color-accent: #58a6ff;\n    --tp-color-muted: #8b949e;\n    --tp-color-error: #f85149;\n\n    /* ==========================================================================\n       TIER 2: SEMANTIC TOKENS - Dark Mode Overrides\n       Higher lightness for foregrounds, higher alpha for backgrounds\n       ========================================================================== */\n\n    /* Static text */\n    --tp-static-fg-l: 75%;\n    --tp-static-bg-alpha: 0.08;\n\n    /* Interpolations */\n    --tp-interp-fg-l: 75%;\n    --tp-interp-bg-alpha: 0.18;\n\n    /* Nested prompts */\n    --tp-nested-fg-l: 78%;\n    --tp-nested-bg-alpha: 0.22;\n\n    /* Lists */\n    --tp-list-fg-l: 72%;\n    --tp-list-bg-alpha: 0.24;\n\n    /* Images */\n    --tp-image-fg-l: 80%;\n    --tp-image-bg-alpha: 0.18;\n\n    /* Unknown */\n    --tp-unknown-fg-l: 75%;\n    --tp-unknown-bg-alpha: 0.22;\n  }\n}\n\n/* Main widget container - three-pane grid layout */\n.tp-widget-container {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  gap: var(--tp-spacing);\n  font-family: var(--tp-font-family);\n  font-size: 14px;\n  color: var(--tp-color-fg);\n  background: var(--tp-color-bg);\n  border: 1px solid var(--tp-color-border);\n  border-radius: 6px;\n  padding: var(--tp-spacing);\n  margin: calc(var(--tp-spacing) * 2) 0;\n  max-width: 100%;\n  overflow: hidden;\n}\n\n/* Output container for chunks */\n.tp-output-container {\n  font-family: var(--tp-font-mono);\n  font-size: 12px;\n  line-height: 1.6;\n  color: var(--tp-color-fg);\n  max-width: 100ch;\n  word-break: break-all;\n  position: relative;\n}\n\n/* Wrapping mode (default) */\n.tp-output-container.wrap {\n  white-space: pre-wrap;\n}\n\n/* Scrolling mode (horizontal scroll, no wrapping) */\n.tp-output-container.scroll {\n  white-space: pre;\n  overflow-x: auto;\n}\n\n/* =============================================================================\n   TIER 3: APPLIED STYLES - Chunk Element Types\n   Semantic colors applied using the three-tier variable system\n   ============================================================================= */\n\n/* Static text - neutral baseline */\n.tp-chunk-static {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-static),\n    var(--tp-static-fg-s),\n    var(--tp-static-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-static),\n    20%,\n    60%,\n    var(--tp-static-bg-alpha)\n  );\n}\n\n/* Interpolations - blue for dynamic data */\n.tp-chunk-interpolation {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-interpolation),\n    var(--tp-interp-fg-s),\n    var(--tp-interp-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-interpolation),\n    80%,\n    60%,\n    var(--tp-interp-bg-alpha)\n  );\n}\n\n/* Nested prompts - purple for composition */\n.tp-chunk-nested_prompt {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-nested),\n    var(--tp-nested-fg-s),\n    var(--tp-nested-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-nested),\n    75%,\n    65%,\n    var(--tp-nested-bg-alpha)\n  );\n}\n\n/* Lists - teal for collections */\n.tp-chunk-list {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-list),\n    var(--tp-list-fg-s),\n    var(--tp-list-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-list),\n    70%,\n    60%,\n    var(--tp-list-bg-alpha)\n  );\n}\n\n/* Images - orange for media, with text elision */\n.tp-chunk-image {\n  white-space: nowrap;\n  max-width: 200px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: inline-block;\n  vertical-align: middle;\n  color: hsl(\n    var(--tp-hue-image),\n    var(--tp-image-fg-s),\n    var(--tp-image-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-image),\n    85%,\n    65%,\n    var(--tp-image-bg-alpha)\n  );\n}\n\n/* Image container for hover preview */\n.tp-chunk-image-container {\n  position: relative;\n  display: inline-block;\n  overflow: visible !important; /* Override overflow: hidden from tp-chunk-image class */\n}\n\n/* Hidden image preview - shown on hover */\n.tp-chunk-image-preview {\n  display: none;\n  position: absolute;\n  left: 100%;\n  top: 0;\n  margin-left: 8px;\n  z-index: 1000;\n  max-width: 400px;\n  max-height: 400px;\n  border: 2px solid var(--tp-color-border);\n  border-radius: 4px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  background: var(--tp-color-bg);\n}\n\n/* Show preview on hover */\n.tp-chunk-image-container:hover .tp-chunk-image-preview {\n  display: block;\n}\n\n/* Unknown types - red warning */\n.tp-chunk-unknown {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-unknown),\n    var(--tp-unknown-fg-s),\n    var(--tp-unknown-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-unknown),\n    80%,\n    60%,\n    var(--tp-unknown-bg-alpha)\n  );\n}\n\n/* Element boundary markers - type-specific borders */\n/* Borders use each element type's semantic hue for visual consistency */\n\n/* No borders for static elements (baseline) */\n.tp-first-static,\n.tp-last-static {\n  /* Static elements have no boundary borders */\n}\n\n/* 1px borders for interpolation (blue, hue 212) */\n.tp-first-interpolation {\n  box-shadow: inset 1px 0 0 0 hsl(212, 90%, 45%);\n  padding-left: 1px;\n}\n\n.tp-last-interpolation {\n  box-shadow: inset -1px 0 0 0 hsl(212, 90%, 55%);\n  padding-right: 1px;\n}\n\n/* 1px borders for image (orange, hue 30) */\n.tp-first-image {\n  box-shadow: inset 1px 0 0 0 hsl(30, 90%, 50%);\n  padding-left: 1px;\n}\n\n.tp-last-image {\n  box-shadow: inset -1px 0 0 0 hsl(30, 90%, 60%);\n  padding-right: 1px;\n}\n\n\n/* 1px borders for nested_prompt (purple, hue 270) */\n.tp-first-nested_prompt {\n  box-shadow: inset 1px 0 0 0 hsl(270, 85%, 50%);\n  padding-left: 1px;\n}\n\n.tp-last-nested_prompt {\n  box-shadow: inset -1px 0 0 0 hsl(270, 85%, 60%);\n  padding-right: 1px;\n}\n\n/* 1px borders for list (teal, hue 160) - higher priority, placed last */\n.tp-first-list {\n  box-shadow: inset 1px 0 0 0 hsl(160, 80%, 40%);\n  padding-left: 1px;\n}\n\n.tp-last-list {\n  box-shadow: inset -1px 0 0 0 hsl(160, 80%, 50%);\n  padding-right: 1px;\n}\n\n\n/* Dark mode adjustments for boundaries - lighter colors for better visibility */\n@media (prefers-color-scheme: dark) {\n  .tp-first-interpolation {\n    box-shadow: inset 1px 0 0 0 hsl(212, 90%, 60%);\n  }\n\n  .tp-last-interpolation {\n    box-shadow: inset -1px 0 0 0 hsl(212, 90%, 70%);\n  }\n\n  .tp-first-image {\n    box-shadow: inset 1px 0 0 0 hsl(30, 90%, 65%);\n  }\n\n  .tp-last-image {\n    box-shadow: inset -1px 0 0 0 hsl(30, 90%, 75%);\n  }\n\n  .tp-first-nested_prompt {\n    box-shadow: inset 1px 0 0 0 hsl(270, 85%, 65%);\n  }\n\n  .tp-last-nested_prompt {\n    box-shadow: inset -1px 0 0 0 hsl(270, 85%, 75%);\n  }\n\n  .tp-first-list {\n    box-shadow: inset 1px 0 0 0 hsl(160, 80%, 55%);\n  }\n\n  .tp-last-list {\n    box-shadow: inset -1px 0 0 0 hsl(160, 80%, 65%);\n  }\n}\n\n/* Error display */\n.tp-error {\n  color: var(--tp-color-error);\n  font-family: var(--tp-font-mono);\n  font-size: 12px;\n  padding: var(--tp-spacing);\n  background: rgba(248, 81, 73, 0.1);\n  border: 1px solid var(--tp-color-error);\n  border-radius: 4px;\n  margin: var(--tp-spacing) 0;\n}\n\n/* Responsive layout */\n@media (max-width: 1200px) {\n  .tp-widget-container {\n    grid-template-columns: 1fr;\n  }\n\n  .tp-pane {\n    max-height: 400px;\n  }\n}\n\n@media (min-width: 1201px) and (max-width: 1600px) {\n  .tp-widget-container {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n", "// Auto-generated by build.js - do not edit manually\nexport const STYLES_HASH = '1db616d5';\n"],
  "mappings": "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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ECCO,IAAMC,EAAc,WZSpB,IAAMC,EAAU,cAgBvB,SAASC,GAAqB,CAE5B,IAAMC,EAAU,oBAAoBC,CAAW,GAI/C,GAAI,SAAS,cAAc,IAAID,CAAO,EAAE,EACtC,OAIgB,SAAS,iBAAiB,0BAA0B,EAC5D,QAAQE,GAAMA,EAAG,OAAO,CAAC,EAGnC,IAAMC,EAAe,SAAS,cAAc,OAAO,EACnDA,EAAa,GAAKH,EAClBG,EAAa,YAAcC,EAC3B,SAAS,KAAK,YAAYD,CAAY,EAElC,OAAO,aACT,OAAO,WAAW,eAAiB,GAEvC,CAKA,SAASE,GAAoB,CACtB,OAAO,aACV,OAAO,WAAa,CAClB,QAASP,EACT,WAAAQ,EACA,eAAgB,EAClB,EAEJ,CAKA,SAASC,GAAiB,CACxBF,EAAY,EACZN,EAAa,EAGM,SAAS,iBAAiB,kBAAkB,EACpD,QAASS,GAAc,CAC5BA,aAAqB,aAAe,CAACA,EAAU,QAAQ,gBACzDF,EAAWE,CAAS,EACpBA,EAAU,QAAQ,cAAgB,OAEtC,CAAC,CACH,CAGI,SAAS,aAAe,UAC1B,SAAS,iBAAiB,mBAAoBD,CAAQ,EAEtDA,EAAS,EAIP,OAAO,iBAAqB,KACb,IAAI,iBAAkBE,GAAc,CACnDA,EAAU,QAASC,GAAa,CAC9BA,EAAS,WAAW,QAASC,GAAS,CAChCA,aAAgB,cAEdA,EAAK,QAAQ,kBAAkB,GAAK,CAACA,EAAK,QAAQ,gBACpDN,EAAY,EACZN,EAAa,EACbO,EAAWK,CAAI,EACfA,EAAK,QAAQ,cAAgB,QAGfA,EAAK,iBAAiB,kBAAkB,EAChD,QAASC,GAAW,CACtBA,aAAkB,aAAe,CAACA,EAAO,QAAQ,gBACnDP,EAAY,EACZN,EAAa,EACbO,EAAWM,CAAM,EACjBA,EAAO,QAAQ,cAAgB,OAEnC,CAAC,EAEL,CAAC,CACH,CAAC,CACH,CAAC,EAGQ,QAAQ,SAAS,KAAM,CAC9B,UAAW,GACX,QAAS,EACX,CAAC",
  "names": ["src_exports", "__export", "VERSION", "initRuntime", "initWidget", "injectStyles", "trimSourcePrefix", "filepath", "prefix", "normalizedPrefix", "formatSourceLocation", "location", "sourcePrefix", "path", "relativePath", "buildElementLocationMap", "promptData", "map", "walkElements", "elements", "element", "sourceLoc", "creationLoc", "buildElementTypeMap", "computeWidgetMetadata", "data", "getChunkId", "element", "copyChunkId", "fromElement", "toElement", "chunkId", "addToChunksMap", "map", "existing", "removeFromChunksMap", "index", "applyTransform_CreateChunks", "state", "element", "chunks", "data", "chunk", "chunkElement", "span", "imgData", "format", "dataUrl", "chunkText", "addToChunksMap", "applyTransform_AddTyping", "state", "chunks", "data", "metadata", "chunk", "elements", "chunkElement", "elementType", "location", "applyTransform_ImageTruncate", "state", "chunks", "chunkElement", "imageData", "truncatedText", "applyTransform_ImageHoverPreview", "state", "chunks", "chunkId", "elements", "chunkElement", "imageData", "format", "dataUrl", "container", "copyChunkId", "textSpan", "previewImg", "removeFromChunksMap", "addToChunksMap", "applyTransform_MarkBoundaries", "state", "chunks", "data", "metadata", "elementId", "chunkIds", "elementType", "firstChunkId", "firstElements", "el", "lastChunkId", "lastElements", "buildCodeView", "data", "metadata", "element", "chunks", "state", "applyTransform_CreateChunks", "applyTransform_AddTyping", "applyTransform_ImageTruncate", "applyTransform_ImageHoverPreview", "applyTransform_MarkBoundaries", "ids", "id", "elements", "el", "buildWidgetContainer", "data", "metadata", "element", "codeView", "buildCodeView", "views", "ids", "view", "index", "initWidget", "container", "scriptTag", "data", "metadata", "computeWidgetMetadata", "widget", "buildWidgetContainer", "mountPoint", "error", "styles_default", "STYLES_HASH", "VERSION", "injectStyles", "styleId", "STYLES_HASH", "el", "styleElement", "styles_default", "initRuntime", "initWidget", "autoInit", "container", "mutations", "mutation", "node", "widget"]
}
